{"cells":[{"cell_type":"code","execution_count":1,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"elapsed":28342,"status":"ok","timestamp":1764539744792,"user":{"displayName":"Gabriela Gonzalez Ayala","userId":"16947320074344909222"},"user_tz":480},"id":"4fl8CXdP9vfv","outputId":"a56c99f6-b1d9-4bb5-c99e-b73b9cdb1efe"},"outputs":[{"output_type":"stream","name":"stdout","text":["\u001b[?25l     \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m0.0/41.6 kB\u001b[0m \u001b[31m?\u001b[0m eta \u001b[36m-:--:--\u001b[0m\r\u001b[2K     \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m41.6/41.6 kB\u001b[0m \u001b[31m1.2 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[?25h  Installing build dependencies ... \u001b[?25l\u001b[?25hdone\n","  Getting requirements to build wheel ... \u001b[?25l\u001b[?25hdone\n","  Preparing metadata (pyproject.toml) ... \u001b[?25l\u001b[?25hdone\n","\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m117.1/117.1 kB\u001b[0m \u001b[31m9.7 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m79.9/79.9 MB\u001b[0m \u001b[31m11.7 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m52.7/52.7 kB\u001b[0m \u001b[31m3.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m12.4/12.4 MB\u001b[0m \u001b[31m122.1 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m1.6/1.6 MB\u001b[0m \u001b[31m69.2 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m76.7/76.7 kB\u001b[0m \u001b[31m5.8 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m59.8/59.8 kB\u001b[0m \u001b[31m4.2 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m73.7/73.7 kB\u001b[0m \u001b[31m5.5 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n","\u001b[?25h  Building wheel for georinex (pyproject.toml) ... \u001b[?25l\u001b[?25hdone\n"]}],"source":["# install gnss_lib_py\n","%pip install gnss_lib_py --quiet"]},{"cell_type":"code","execution_count":3,"metadata":{"id":"_03j3yvv90GA","executionInfo":{"status":"ok","timestamp":1764539895817,"user_tz":480,"elapsed":8630,"user":{"displayName":"Gabriela Gonzalez Ayala","userId":"16947320074344909222"}},"colab":{"base_uri":"https://localhost:8080/"},"outputId":"b679a80a-7e56-48de-d1f5-2a46191bd557"},"outputs":[{"output_type":"stream","name":"stdout","text":["Mounted at /content/drive\n"]}],"source":["import numpy as np\n","import gnss_lib_py as glp\n","import matplotlib.pyplot as plt\n","import pandas as pd\n","from datetime import datetime\n","from google.colab import drive\n","drive.mount('/content/drive')"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0lQtryKf-j2o"},"outputs":[],"source":["# parse the raw text file directly\n","navdata = glp.AndroidRawGnss(input_path=\"/content/drive/MyDrive/AA272/FinalProject/gnss_log_2025_11_06_13_39_54.txt\")"]},{"cell_type":"code","source":["truth = pd.read_csv(\"/content/drive/MyDrive/AA272/gnss_logs/gaia_together_named.csv\")\n","truth2 = pd.read_csv(\"/content/drive/MyDrive/AA272/gnss_logs/gaia_angela_named.csv\")\n","truth3 = pd.read_csv(\"/content/drive/MyDrive/AA272/gnss_logs/gaia_gaby_named.csv\")"],"metadata":{"id":"T42r9OxZgleL","executionInfo":{"status":"ok","timestamp":1764540114850,"user_tz":480,"elapsed":231,"user":{"displayName":"Gabriela Gonzalez Ayala","userId":"16947320074344909222"}}},"execution_count":12,"outputs":[]},{"cell_type":"code","source":["for i in range(len(truth[\"time\"])):\n","  truth[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth['time'][i].replace(\"Z\", \"+00:00\")))\n","for i in range(len(truth2[\"time\"])):\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","for i in range(len(truth3[\"time\"])):\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))"],"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"collapsed":true,"id":"ZmOn7Uijg0sG","executionInfo":{"status":"ok","timestamp":1764540116561,"user_tz":480,"elapsed":1077,"user":{"displayName":"Gabriela Gonzalez Ayala","userId":"16947320074344909222"}},"outputId":"ca3d96ac-45d2-487d-c6bd-acddb73f8e86"},"execution_count":13,"outputs":[{"output_type":"stream","name":"stderr","text":["\u001b[1;30;43mStreaming output truncated to the last 5000 lines.\u001b[0m\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:4: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth2[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth2['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\n","You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\n","A typical example is when you are setting values in a column of a DataFrame, like:\n","\n","df[\"col\"][row_indexer] = value\n","\n","Use `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n","/tmp/ipython-input-1275913304.py:6: SettingWithCopyWarning: \n","A value is trying to be set on a copy of a slice from a DataFrame\n","\n","See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n","  truth3[\"time\"][i] = glp.datetime_to_gps_millis(datetime.fromisoformat(truth3['time'][i].replace(\"Z\", \"+00:00\")))\n"]}]},{"cell_type":"code","source":["plt.plot(truth[\"time\"],truth[\"alt_rx_gaia_m\"],'.')\n","plt.xlabel(\"Time [ms]\")\n","plt.ylabel(\"Altitude [m]\")"],"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":466},"id":"PY5VMe8-ldDx","executionInfo":{"status":"ok","timestamp":1764540118838,"user_tz":480,"elapsed":141,"user":{"displayName":"Gabriela Gonzalez Ayala","userId":"16947320074344909222"}},"outputId":"9c43f309-903e-4ecc-a5c0-c4292d5ef45b"},"execution_count":14,"outputs":[{"output_type":"execute_result","data":{"text/plain":["Text(0, 0.5, 'Altitude [m]')"]},"metadata":{},"execution_count":14},{"output_type":"display_data","data":{"text/plain":["<Figure size 640x480 with 1 Axes>"],"image/png":"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f/Tt2xf79u3DsGHD5G4akWJwzg4RERGpGuvsEBERkaox2CEiIiJVY7BDREREqsZgh4iIiFSNwQ4RERGpGoMdIiIiUjUGO0RERKRqDHaIiMjtHTlyBElJSdBqtRAEATt27LD5HJIk4e2330aPHj3g5eWFLl264M9//nOL2/TPf/4TiYmJ6NixIwRBQH5+vk3P//TTTyEIQpPrEr7wwgsQBAGrVq0y2ffFF19g4MCBaN++PQIDA03OIwiCyePTTz+1qY0bNmzA0KFD4efnB0EQUF5ebrT/0qVLmDp1KiIiItC+fXt0794dixYtws8//2zT6zDYISLZPPfcc7IsELt582bDzXnWrFkOe51Lly4ZXqd///4Oex1qverqavTr1w/vvfdei8/x8ssv44MPPsDbb7+N77//Hjt37sSAAQMsHv/66683WZ28uroaQ4YMwcqVK21uy6VLl5CamoqHHnrI4jHbt2/H8ePHodVqTfb94x//wIQJEzB58mScOnUKX3/9Nf7whz+YHLdp0yaUlpYaHra+n2/duoURI0bgv//7v83u//7771FXV4f169fj22+/xTvvvIN169ZZPN4iiYjIAQA0+Vi0aJFUXl4u3bx50+lt27Rpk+Tn5yeVlpZKlZWVDnudO3fuSKWlpdKcOXOkfv36Oex1yL4ASNu3bzfa9tNPP0lz5syRtFqt1KFDB2nAgAHSwYMHDfvPnDkjeXp6St9//73Vr7No0SJp0qRJzR5XVFQkAZDy8vKsOu+dO3ekBx98UPrggw+kSZMmSaNHjzY55sqVK1KXLl2k06dPS127dpXeeecdw76amhqpS5cu0gcffNDk65j7PjW2Y8cOKTo6WvLy8pIiIiKk119/XaqpqTE57uDBgxIAq+4Hb775phQREdHscQ2xZ4eIHKLhX3urVq2Cn5+f0bbU1FT4+/sjICBAlvYJgoCQkBD4+vo67DU8PDwQEhICHx8fh70GOcdLL72EY8eO4dNPP8U333yDp556CiNGjMD58+cBALt27UJkZCR2796NiIgIdOvWDX/84x9x48YNp7d1yZIl6Ny5M6ZOnWp2f11dHSZMmIBXX30V9913n8n+3NxclJSUQKPRIDo6GqGhoRg5ciROnz5tcuz06dPRqVMnDBgwAB999BGkBitQffXVV5g4cSJefvllnDlzBuvXr8fmzZtbNbQHABUV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\n"},"metadata":{}}]},{"cell_type":"code","source":["plt.plot((truth[\"time\"]-truth[\"time\"][0])*1e-3/60,truth[\"alt_rx_gaia_m\"],'.')\n","plt.plot((truth2[\"time\"]-truth2[\"time\"][0])*1e-3/60,truth2[\"alt_rx_gaia_m\"],'.')\n","plt.plot((truth3[\"time\"]-truth3[\"time\"][0])*1e-3/60,truth3[\"alt_rx_gaia_m\"],'.')\n","plt.xlabel(\"Time [mins]\")\n","plt.ylabel(\"Elevation [m]\")\n","plt.legend([\"Together\",\"Angela\",\"Gaby\"])"],"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":466},"id":"pvor1lgtbZdB","executionInfo":{"status":"ok","timestamp":1764540120405,"user_tz":480,"elapsed":183,"user":{"displayName":"Gabriela Gonzalez Ayala","userId":"16947320074344909222"}},"outputId":"a59573a5-86b2-4de3-99af-77f970f3c4b2"},"execution_count":15,"outputs":[{"output_type":"execute_result","data":{"text/plain":["<matplotlib.legend.Legend at 0x7c3ef9ab4b00>"]},"metadata":{},"execution_count":15},{"output_type":"display_data","data":{"text/plain":["<Figure size 640x480 with 1 Axes>"],"image/png":"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\n"},"metadata":{}}]},{"cell_type":"code","source":["import math\n","\n","def haversine(lat1, lon1, lat2, lon2):\n","    R = 6371000  # Earth radius in meters\n","    phi1, phi2 = math.radians(lat1), math.radians(lat2)\n","    d_phi = math.radians(lat2 - lat1)\n","    d_lambda = math.radians(lon2 - lon1)\n","\n","    a = math.sin(d_phi / 2) ** 2 + math.cos(phi1) * math.cos(phi2) * math.sin(d_lambda / 2) ** 2\n","    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n","    return R * c\n","\n","def cumulative_distance_from_df(df, lat_col='lat', lon_col='lon', elev_col='alt'):\n","    \"\"\"\n","    df: pandas DataFrame with latitude, longitude, and elevation columns\n","    lat_col, lon_col, elev_col: column names in df\n","\n","    Returns cumulative 3D distance in meters\n","    \"\"\"\n","    total_distance = [0.0]\n","    for i in range(1, len(df)):\n","        lat1, lon1, ele1 = df.iloc[i-1][[lat_col, lon_col, elev_col]]\n","        lat2, lon2, ele2 = df.iloc[i][[lat_col, lon_col, elev_col]]\n","\n","        dist_2d = haversine(lat1, lon1, lat2, lon2)\n","        # delta_elev = ele2 - ele1\n","        # dist_3d = math.sqrt(dist_2d**2 + delta_elev**2)\n","        total_distance.append(total_distance[i-1]+dist_2d)\n","\n","    return total_distance\n","\n","# def speed_from_df(cum_dist, df, time_col='time'):\n","#     speed = np.zeros(len(cum_dist))\n","#     for i in range(1,len(cum_dist)):\n","#       t1 = df.iloc[i-1][time_col]\n","#       t2 = df.iloc[i][time_col]\n","#       speed[i] = (cum_dist[i]-cum_dist[i-1])/((t2-t1) * 1e-3)\n","#     return speed"],"metadata":{"id":"L3SCNi8QGkDP"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["cum_dist = cumulative_distance_from_df(truth)\n","# slope = slope_from_df(cum_dist,truth)\n","# speed = speed_from_df(cum_dist,truth)\n","len(truth[\"alt\"])"],"metadata":{"id":"WAH9WgU3HePJ"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["from shapely.geometry import LineString\n","\n","def segment_curve(points, epsilon):\n","    \"\"\"\n","    points: list of (x, y) along curve\n","    epsilon: max allowed deviation from original curve\n","    returns: list of segment endpoints [(x0,y0)->(x1,y1)->...]\n","    \"\"\"\n","    line = LineString(points)\n","    simplified = line.simplify(epsilon, preserve_topology=False)\n","    return list(simplified.coords)\n","\n","points = []\n","for i in range(len(cum_dist)):\n","  points.append((cum_dist[i],truth[\"alt\"][i]))\n","\n","segments = segment_curve(points, 5)"],"metadata":{"id":"LjobAGTfV1Ov"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["plt.plot(cum_dist,truth[\"alt\"],'.')\n","plt.title(\"Ground Truth (Gaia)\")\n","plt.xlabel(\"Distance [m]\")\n","plt.ylabel(\"Elevation [m]\")"],"metadata":{"id":"wJKZwhU6HoV7"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["segments"],"metadata":{"id":"njxwnTg7bROg"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["plt.plot(cum_dist,truth[\"alt\"],'.')\n","for segment in segments:\n","  plt.plot(segment[0],segment[1],'.',color = 'C1',markersize=10)\n","plt.xlabel(\"Distance [m]\")\n","plt.ylabel(\"Elevation [m]\")\n","plt.title(\"Ground Truth (Gaia) with Segments\")"],"metadata":{"id":"WXyJEbLub1sZ"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# find corresponding indices in cum_dist to all in segments\n","indices = []\n","for segment in segments:\n","  for i in range(len(cum_dist)):\n","    if cum_dist[i] == segment[0]:\n","      indices.append(i)\n","print(indices)"],"metadata":{"id":"lN5oHeK1gNbt"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# # remove 290 from indices list as that seems to be from noise\n","# indices.remove(290)\n","# indices.remove(30)"],"metadata":{"id":"0zjiCDpJfnXM"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["analysis_slope = []\n","analysis_speed = []\n","for i in range(len(indices)-1):\n","  slope = (truth[\"alt\"][indices[i+1]]-truth[\"alt\"][indices[i]])/(cum_dist[indices[i+1]]-cum_dist[indices[i]])\n","  speed = (cum_dist[indices[i+1]]-cum_dist[indices[i]])/((truth[\"time\"][indices[i+1]]-truth[\"time\"][indices[i]])*1e-3)\n","  analysis_slope.append(slope)\n","  analysis_speed.append(speed)\n","\n","plt.plot(analysis_slope,analysis_speed,'.')\n","plt.xlabel(\"Slope\")\n","plt.ylabel(\"Speed [m/s]\")"],"metadata":{"id":"XE3LOqJwBPpU"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# run linear regression on analysis_slope and analysis_speed\n","from sklearn.linear_model import LinearRegression\n","X = np.array(analysis_slope).reshape(-1, 1)\n","y = np.array(analysis_speed)\n","model = LinearRegression().fit(X, y)\n","# plot analysis points with linear regression line\n","plt.plot(analysis_slope,analysis_speed,'.')\n","plt.plot(X, model.predict(X), color='green')\n","plt.xlabel(\"Slope\")\n","plt.ylabel(\"Speed [m/s]\")"],"metadata":{"id":"1v5Rbo--EchM"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["cum_dist2 = cumulative_distance_from_df(truth2)\n","points2 = []\n","for i in range(len(cum_dist2)):\n","  points2.append((cum_dist2[i],truth2[\"alt\"][i]))\n","\n","segments2 = segment_curve(points2, 4.5)\n","\n","plt.plot(cum_dist,truth[\"alt\"],'.')\n","plt.title(\"Ground Truth (Gaia) Angela\")\n","plt.xlabel(\"Distance [m]\")\n","plt.ylabel(\"Elevation [m]\")"],"metadata":{"id":"-ggi1a1fF1tK"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["plt.plot(cum_dist2,truth2[\"alt\"],'.')\n","for segment in segments2:\n","  plt.plot(segment[0],segment[1],'.',color = 'C1',markersize=10)\n","plt.xlabel(\"Distance [m]\")\n","plt.ylabel(\"Elevation [m]\")\n","plt.title(\"Ground Truth (Gaia) with Segments (Angela)\")"],"metadata":{"id":"QM_kugWMF7ke"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# find corresponding indices in cum_dist to all in segments\n","indices2 = []\n","for segment in segments2:\n","  for i in range(len(cum_dist2)):\n","    if cum_dist2[i] == segment[0]:\n","      indices2.append(i)\n","print(indices2)"],"metadata":{"id":"HGhVNetBG9OH"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# indices2.remove(406)\n","analysis_slope = []\n","analysis_speed = []\n","for i in range(len(indices2)-1):\n","  slope = (truth2[\"alt\"][indices2[i+1]]-truth2[\"alt\"][indices2[i]])/(cum_dist2[indices2[i+1]]-cum_dist2[indices2[i]])\n","  speed = (cum_dist2[indices2[i+1]]-cum_dist2[indices2[i]])/((truth2[\"time\"][indices2[i+1]]-truth2[\"time\"][indices2[i]])*1e-3)\n","  analysis_slope.append(slope)\n","  analysis_speed.append(speed)\n","  # print(slope,speed)\n","\n","plt.plot(analysis_slope,analysis_speed,'.')\n","plt.xlabel(\"Slope\")\n","plt.ylabel(\"Speed [m/s]\")"],"metadata":{"id":"w3m6CIHEK3t9"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["X2 = np.array(analysis_slope).reshape(-1, 1)\n","y2 = np.array(analysis_speed)\n","model2 = LinearRegression().fit(X2, y2)\n","# plot analysis points with linear regression line\n","plt.plot(analysis_slope,analysis_speed,'.')\n","plt.plot(X2, model2.predict(X2), color='green')\n","plt.xlabel(\"Slope\")\n","plt.ylabel(\"Speed [m/s]\")"],"metadata":{"id":"IjU4X4F3Q_sl"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["cum_dist3 = cumulative_distance_from_df(truth3)\n","points3 = []\n","for i in range(len(cum_dist3)):\n","  points3.append((cum_dist3[i],truth3[\"alt\"][i]))\n","\n","segments3 = segment_curve(points3, 4.5)\n","\n","plt.plot(cum_dist3,truth3[\"alt\"],'.')\n","plt.title(\"Ground Truth (Gaia) Gaby\")\n","plt.xlabel(\"Distance [m]\")\n","plt.ylabel(\"Elevation [m]\")"],"metadata":{"id":"d0CnJ6hWSWVJ"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["plt.plot(cum_dist3,truth3[\"alt\"],'.')\n","for segment in segments3:\n","  plt.plot(segment[0],segment[1],'.',color = 'C1',markersize=10)\n","plt.xlabel(\"Distance [m]\")\n","plt.ylabel(\"Elevation [m]\")\n","plt.title(\"Ground Truth (Gaia) with Segments (Gaby)\")"],"metadata":{"id":"Hz5t3McuVGGE"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# find corresponding indices in cum_dist to all in segments\n","indices3 = []\n","for segment in segments3:\n","  for i in range(len(cum_dist3)):\n","    if cum_dist3[i] == segment[0]:\n","      indices3.append(i)\n","print(indices3)"],"metadata":{"id":"TeysMpNqVSx5"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# indices3.remove(406)\n","analysis_slope = []\n","analysis_speed = []\n","for i in range(len(indices3)-1):\n","  slope = (truth3[\"alt\"][indices3[i+1]]-truth3[\"alt\"][indices3[i]])/(cum_dist3[indices3[i+1]]-cum_dist3[indices3[i]])\n","  speed = (cum_dist3[indices3[i+1]]-cum_dist3[indices3[i]])/((truth3[\"time\"][indices3[i+1]]-truth3[\"time\"][indices3[i]])*1e-3)\n","  analysis_slope.append(slope)\n","  analysis_speed.append(speed)\n","  # print(slope,speed)\n","\n","plt.plot(analysis_slope,analysis_speed,'.')\n","plt.xlabel(\"Slope\")\n","plt.ylabel(\"Speed [m/s]\")"],"metadata":{"id":"KIT59tSZVXz8"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["X3 = np.array(analysis_slope).reshape(-1, 1)\n","y3 = np.array(analysis_speed)\n","model3 = LinearRegression().fit(X3, y3)\n","# plot analysis points with linear regression line\n","plt.plot(analysis_slope,analysis_speed,'.')\n","plt.plot(X3, model3.predict(X3), color='green')\n","plt.xlabel(\"Slope\")\n","plt.ylabel(\"Speed [m/s]\")"],"metadata":{"id":"0rvO-l6JVqCE"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["plt.plot(X, model.predict(X))\n","plt.plot(X2, model2.predict(X2))\n","plt.plot(X3, model3.predict(X3))\n","plt.xlabel(\"Slope\")\n","plt.ylabel(\"Speed [m/s]\")\n","plt.legend([\"Together\",\"Angela\",\"Gaby\"])"],"metadata":{"id":"-h68gxOyVy_2"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["## NAVDATA ##"],"metadata":{"id":"cCsAJB4kG3T-"}},{"cell_type":"code","source":["navdata.rows"],"metadata":{"id":"oXAND15k58W3"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# for i in range(len(navdata[\"# Raw\"])):\n","#   if navdata[\"# Raw\"][i] != \"Raw\":\n","#     print(i)"],"metadata":{"id":"i6VamjU49Ch4"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# len(navdata[\"# Raw\"])"],"metadata":{"id":"BHSbqQNYNCDg"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# rename SvPositionEcefXMeters to x_sv_m\n","# navdata = navdata.rename(columns={\"SvPositionEcefXMeters\": \"x_sv_m\", \"SvPositionEcefYMeters\": \"y_sv_m\", \"SvPositionEcefZMeters\": \"z_sv_m\"})\n","navdata[\"x_sv_m\"] = navdata[\"SvPositionEcefXMeters\"]\n","navdata[\"y_sv_m\"] = navdata[\"SvPositionEcefYMeters\"]\n","navdata[\"z_sv_m\"] = navdata[\"SvPositionEcefZMeters\"]"],"metadata":{"id":"CGVM_AqKNo8E"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# Constants\n","LIGHT_SPEED = 299792458  # meters per second\n","\n","# Compute GNSS week number in nanoseconds\n","week_nanos = np.floor(-navdata[\"FullBiasNanos\"] / 604800e9) * 604800e9\n","\n","# Compute true time of reception in GNSS time\n","tRx = navdata[\"TimeNanos\"] - (navdata[\"FullBiasNanos\"] + navdata[\"BiasNanos\"]) - week_nanos\n","\n","# Compute transmission time (usually just ReceivedSvTimeNanos)\n","# Check if 'TimeOffsetNanos' exists, otherwise use 0\n","if navdata.in_rows(\"TimeOffsetNanos\"):\n","    time_offset_nanos_val = navdata[\"TimeOffsetNanos\"]\n","else:\n","    time_offset_nanos_val = 0\n","tTx = navdata[\"ReceivedSvTimeNanos\"] + time_offset_nanos_val\n","\n","# Pseudorange in meters\n","navdata[\"corr_pr_m\"] = (tRx - tTx) * LIGHT_SPEED * 1e-9"],"metadata":{"id":"8zcktj39Pua0"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["### Fix Data"],"metadata":{"id":"Aji33uantE_b"}},{"cell_type":"code","source":["fix_data_Angela = glp.AndroidRawFixes(\"/content/drive/MyDrive/AA272/gnss_logs/gnss_log_2025_11_09_16_24_58.txt\")\n","fix_data_Gaby = glp.AndroidRawFixes(\"/content/drive/MyDrive/AA272/gnss_logs/gnss_log_2025_11_11_14_21_02.txt\")\n","fix_data_Together = glp.AndroidRawFixes(\"/content/drive/MyDrive/AA272/gnss_logs/gnss_log_2025_11_06_13_39_54.txt\")\n","\n","\"\"\"\n","fix_types = np.unique(fix_data[\"fix_provider\"]).tolist()\n","fixes = []\n","for provider in fix_types:\n","    fix_provider = fix_data.where(\"fix_provider\",provider)\n","    fix_provider.rename({\"lat_rx_deg\":\"lat_rx_\" + provider + \"_deg\",\n","                         \"lon_rx_deg\":\"lon_rx_\" + provider + \"_deg\",\n","                         \"alt_rx_m\":\"alt_rx_\" + provider + \"_m\",\n","                         }, inplace=True)\n","    fixes.append(fix_provider)\n","    \"\"\"\n","\n","def get_fix_gnss(fix_data):\n","\n","  fix_types = np.unique(fix_data[\"fix_provider\"]).tolist()\n","\n","  fixes_gnss = []\n","  for provider in fix_types:\n","    if provider==\"gnss\":\n","      fix_provider = fix_data.where(\"fix_provider\",provider)\n","      fix_provider.rename({\"lat_rx_deg\":\"lat_rx_\" + provider + \"_deg\",\n","                          \"lon_rx_deg\":\"lon_rx_\" + provider + \"_deg\",\n","                          \"alt_rx_m\":\"alt_rx_\" + provider + \"_m\",\n","                          }, inplace=True)\n","      fixes_gnss.append(fix_provider)\n","  return fixes_gnss\n","\n","fixes_gnss_Angela = get_fix_gnss(fix_data_Angela)\n","fixes_gnss_Gaby = get_fix_gnss(fix_data_Gaby)\n","fixes_gnss_Together = get_fix_gnss(fix_data_Together)\n","\n","#fig_fix = glp.plot_map(*fixes_gnss) #Map Plotting"],"metadata":{"id":"pPUd9Z4dqUoQ","executionInfo":{"status":"ok","timestamp":1764540168800,"user_tz":480,"elapsed":25249,"user":{"displayName":"Gabriela Gonzalez Ayala","userId":"16947320074344909222"}}},"execution_count":17,"outputs":[]},{"cell_type":"markdown","metadata":{"id":"-LrgdkY97_XS"},"source":["## Default Weighted Least Squares"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"0UXFAYAm-tiN"},"outputs":[],"source":["\n","wls_estimate_default = glp.solve_wls(navdata)"]},{"cell_type":"code","source":["navdata = glp.AndroidRawGnss(input_path=\"/content/drive/MyDrive/AA272/FinalProject/gnss_log_2025_11_06_13_39_54.txt\").where(\"gnss_id\",(\"gps\", \"galileo\", \"beidou\"))\n"],"metadata":{"id":"0i0oHldPDmWe"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["navdata = glp.AndroidRawGnss(input_path=\"/content/drive/MyDrive/AA272/gnss_logs/gnss_log_2025_11_06_13_39_54.txt\")"],"metadata":{"id":"jnv9TvpYDt_Z"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":[],"metadata":{"id":"MCCTFRJGEFO0"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["navdata = glp.AndroidRawGnss(input_path=\"/content/drive/MyDrive/AA272/gnss_logs/gnss_log_2025_11_06_13_39_54.txt\")\n","# navdata = glp.AndroidRawGnss(input_path=\"/content/drive/MyDrive/AA272/gnss_logs/gnss_log_2025_11_11_14_21_02.txt\")\n","\n","navdata = navdata.where('SvClockBiasMeters', np.nan, condition=\"neq\")\n","\n","# navdata[\"x_sv_m\"] = navdata[\"SvPositionEcefXMeters\"]\n","# navdata[\"y_sv_m\"] = navdata[\"SvPositionEcefYMeters\"]\n","# navdata[\"z_sv_m\"] = navdata[\"SvPositionEcefZMeters\"]\n","\n","sp3 = glp.Sp3(\"/content/drive/MyDrive/AA272/gnss_logs/igs23914.sp3\")\n","\n","navdata = navdata.where(\"gnss_id\",(\"gps\"))\n","navdata[\"gnss_sv_id\"] = np.array([f\"G{sv_id:02d}\" for sv_id in navdata[\"sv_id\"]])\n","sp3.interpolate_sp3(navdata)\n","\n","# Pseudorange in meters\n","navdata[\"corr_pr_m\"] = navdata[\"raw_pr_m\"] + navdata['SvClockBiasMeters']\n","\n","navdata[\"weights\"] = 1./(10**(-navdata[\"cn0_dbhz\"]/10.))\n","########################################################################\n","\n","wls_estimate_cn0 = glp.solve_wls(navdata,weight_type=\"weights\")\n","\n","wls_estimate_cn0_pd = wls_estimate_cn0.pandas_df().dropna()\n","wls_estimate=glp.NavData(pandas_df=wls_estimate_cn0_pd)\n","glp.plot_map(wls_estimate)"],"metadata":{"id":"X1loaTk96Zab"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["sp3_rc = glp.Sp3(\"/content/drive/MyDrive/AA272/gnss_logs/igs23914_rc.sp3\")\n","sp3 = glp.Sp3(\"/content/drive/MyDrive/AA272/gnss_logs/igs23914.sp3\")\n","\n","# print(sp3.where(\"sv_id\",(9))[\"gps_millis\"])\n","# print(sp3_rc.where(\"sv_id\",(9))[\"gps_millis\"])\n","\n","plt.plot(sp3.where(\"sv_id\",(9))[\"gps_millis\"], sp3.where(\"sv_id\",(9))[\"z_sv_m\"], \".\", markersize=4)\n","plt.plot(navdata.where(\"sv_id\",(9))[\"gps_millis\"], navdata.where(\"sv_id\",(9))[\"SvPositionEcefZMeters\"], \".\", markersize=1)\n","plt.xlim(navdata[\"gps_millis\"][0], navdata[\"gps_millis\"][-1])\n","\n","print(np.unique(sp3.where(\"gps_millis\",navdata[\"gps_millis\"][0], \"geq\").where(\"gps_millis\",navdata[\"gps_millis\"][-1], \"leq\")[\"gps_millis\"].astype(np.int64)))\n","print(np.unique(navdata[\"gps_millis\"]).astype(np.int64))"],"metadata":{"id":"wjJn0F6oalxw"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["glp.gps_millis_to_datetime(navdata[\"gps_millis\"][0])"],"metadata":{"id":"bq3J1RNSmbs3"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# # plt.plot(wls_estimate_cn0[\"gps_millis\"], wls_estimate_cn0[\"alt_rx_wls_m\"])\n","# wls_estimate_cn0\n","\n","# plt.plot(navdata[\"gps_millis\"], navdata[\"raw_pr_m\"])\n","# real_navdata = glp.AndroidRawGnss(input_path=\"/content/drive/MyDrive/AA272/gnss_logs/gnss_log_2025_11_06_13_39_54.txt\").where(\"sv_id\",(9))\n","real_navdata = real_navdata.where(\"gnss_id\",(\"gps\"))\n","# temp_navdata = navdata.where(\"gnss_id\",(\"gps\")).where(\"sv_id\",(9))\n","temp_navdata = navdata.where(\"sv_id\",(9))\n","# print(np.where(navdata[\"gps_millis\"] == 1446500412999)[0])\n","# print(temp_navdata)\n","\n","# sp3 = glp.Sp3(\"/content/drive/MyDrive/AA272/gnss_logs/igs23914.sp3\")\n","# temp_sp3 = sp3.where(\"gnss_id\",(\"gps\")).where(\"sv_id\",(9))\n","\n","plt.plot(temp_navdata[\"gps_millis\"], temp_navdata[\"z_sv_m\"], markersize=1)\n","plt.plot(real_navdata[\"gps_millis\"], real_navdata[\"SvPositionEcefZMeters\"], markersize=1)"],"metadata":{"id":"hnzPtAdDDNdG"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["plt.plot(navdata.where(\"sv_id\",(9))[\"gps_millis\"], navdata.where(\"sv_id\",(9))[\"SvClockBiasMeters\"], \".\")"],"metadata":{"id":"xqDVwORkbJ8h"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# STFU00USA_S_20253102200_15M_01S_MO.rnx\n","stfu_navdata = glp.RinexNav(\"/content/drive/MyDrive/AA272/gnss_logs/STFU00USA_S_20253102200_15M_01S_MO.rnx\")\n","# glp.read_rnx(\"/content/drive/MyDrive/AA272/gnss_logs/STFU00USA_S_20253102200_15M_01S_MO.rnx\")"],"metadata":{"id":"zAvwbTfh6JCy"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["stfu_navdata.rows"],"metadata":{"id":"3aoMkUQG8krR"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"SQPkAsNEGVIN"},"outputs":[],"source":["wls_estimate_default.rows"]},{"cell_type":"code","source":["plt.plot(wls_estimate_default[\"z_rx_wls_m\"])"],"metadata":{"id":"HpKH4wm53VW9"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["# plt.plot(wls_estimate_default[\"alt_rx_wls_m\"],'.')\n","# unique, counts = np.unique(navdata[\"sv_id\"], return_counts=True)\n","# frequency_map = dict(zip(unique, counts))\n","sat9idx = np.where(navdata[\"sv_id\"] == 9)[0]\n","gps9idx = np.where(navdata[\"gnss_id\"] == \"gps\")[0]\n","sat9gpsidx = np.intersect1d(sat9idx, gps9idx)\n","print(sat9gpsidx)\n","alt = navdata[\"SvPositionEcefZMeters\"][sat9gpsidx]\n","plt.plot(alt, \".\")\n","\n","# plt.ylim(0, 100)"],"metadata":{"id":"Q8isOr10hFZF"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["glp.interpolate(navdata, 'lat_rx_wls_deg', 'lon_rx_wls_deg', 'alt_rx_wls_m', inplace=True)"],"metadata":{"id":"-kAx3d1RfM7s"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["truth[\"time\"]\n","truth[\"alt\"]\n","\n","print(navdata[\"gps_millis\"][17] - navdata[\"gps_millis\"][0])"],"metadata":{"id":"GhrkDaBvwwIn"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"KbpJqpOu-q4J"},"outputs":[],"source":["glp.plot_map(wls_estimate_default)"]},{"cell_type":"code","metadata":{"id":"cb08f97d"},"source":["wls_estimate_interpolated = interpolate_bridge(truth, wls_estimate_default)"],"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":62,"metadata":{"id":"BPfmZ67GBynQ","executionInfo":{"status":"ok","timestamp":1764542707175,"user_tz":480,"elapsed":26,"user":{"displayName":"Gabriela Gonzalez Ayala","userId":"16947320074344909222"}}},"outputs":[],"source":["from gnss_lib_py.navdata.operations import interpolate as navdata_interpolate\n","\n","def interpolate_bridge(ground_truth, estimate):\n","  \"\"\"Interpolate positions under the bridge.\n","\n","  \"\"\"\n","  # copy navdata to avoid overwriting\n","  interpolated = estimate.copy()\n","  row_names = list(set(interpolated.rows)-set([\"gps_millis\"])) # Changed glp.GNSS_TIME_COLUMN to \"gps_millis\"\n","\n","  # Ensure gps_millis are numeric (float then int) for robust conversion and set operations\n","  gt_gps_millis_values = ground_truth[\"gps_millis\"]\n","  interp_gps_millis_values = interpolated[\"gps_millis\"]\n","\n","  gt_gps_millis_cleaned = gt_gps_millis_values.astype(float).astype(np.int64)\n","  interp_gps_millis_cleaned = interp_gps_millis_values.astype(float).astype(np.int64)\n","\n","  missing_timesteps = set(gt_gps_millis_cleaned) - set(interp_gps_millis_cleaned)\n","\n","  new_navdata = glp.NavData()\n","  new_navdata[\"gps_millis\"] = np.array(list(missing_timesteps), dtype=np.int64) # Convert to numpy array of int64\n","  interpolated = glp.concat(interpolated,new_navdata,axis=1)\n","  glp.sort(interpolated,\"gps_millis\",inplace=True) # Changed glp.GNSS_TIME_COLUMN to \"gps_millis\"\n","\n","  # interpolate all values\n","  navdata_interpolate(interpolated,\"gps_millis\",row_names,inplace=True) # Changed glp.GNSS_TIME_COLUMN to \"gps_millis\"\n","\n","  return interpolated"]},{"cell_type":"code","execution_count":69,"metadata":{"id":"bWkQRREEjq1T","colab":{"base_uri":"https://localhost:8080/","height":529},"executionInfo":{"status":"error","timestamp":1764542768367,"user_tz":480,"elapsed":53,"user":{"displayName":"Gabriela Gonzalez Ayala","userId":"16947320074344909222"}},"outputId":"b5d5b243-1b0c-4ce9-cc17-8674e90778eb"},"outputs":[{"output_type":"error","ename":"TypeError","evalue":"Cannot cast array data from dtype('O') to dtype('float64') according to the rule 'safe'","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mTypeError\u001b[0m                                 Traceback (most recent call last)","\u001b[0;32m/tmp/ipython-input-1614671790.py\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mgnss_estimate_interpolated\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0minterpolate_bridge\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtruth\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfixes_gnss_Together\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m","\u001b[0;32m/tmp/ipython-input-3639071060.py\u001b[0m in \u001b[0;36minterpolate_bridge\u001b[0;34m(ground_truth, estimate)\u001b[0m\n\u001b[1;32m     24\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     25\u001b[0m   \u001b[0;31m# interpolate all values\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 26\u001b[0;31m   \u001b[0mnavdata_interpolate\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minterpolated\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\"gps_millis\"\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mrow_names\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0minplace\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mTrue\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;31m# Changed glp.GNSS_TIME_COLUMN to \"gps_millis\"\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     27\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     28\u001b[0m   \u001b[0;32mreturn\u001b[0m \u001b[0minterpolated\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/usr/local/lib/python3.12/dist-packages/gnss_lib_py/navdata/operations.py\u001b[0m in \u001b[0;36minterpolate\u001b[0;34m(navdata, x_row, y_rows, inplace, *args)\u001b[0m\n\u001b[1;32m    246\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    247\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0minplace\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 248\u001b[0;31m             navdata[y_row,nan_idxs] = np.interp(x_vals, xp_vals,\n\u001b[0m\u001b[1;32m    249\u001b[0m                                              yp_vals, *args)\n\u001b[1;32m    250\u001b[0m         \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/usr/local/lib/python3.12/dist-packages/numpy/lib/_function_base_impl.py\u001b[0m in \u001b[0;36minterp\u001b[0;34m(x, xp, fp, left, right, period)\u001b[0m\n\u001b[1;32m   1597\u001b[0m         \u001b[0mfp\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconcatenate\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfp\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m-\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfp\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfp\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1598\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1599\u001b[0;31m     \u001b[0;32mreturn\u001b[0m \u001b[0minterp_func\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mxp\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfp\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mleft\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mright\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1600\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1601\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;31mTypeError\u001b[0m: Cannot cast array data from dtype('O') to dtype('float64') according to the rule 'safe'"]}],"source":["gnss_estimate_interpolated = interpolate_bridge(truth, fixes_gnss_Together[0])"]},{"cell_type":"code","execution_count":66,"metadata":{"id":"UkiLpbaksck7","executionInfo":{"status":"ok","timestamp":1764542740041,"user_tz":480,"elapsed":31,"user":{"displayName":"Gabriela Gonzalez Ayala","userId":"16947320074344909222"}}},"outputs":[],"source":["def error_histogram(ground_truth, estimate):\n","  \"\"\"Plot histogram of errors.\n","\n","  \"\"\"\n","  ##\n","\n","\n","  # Create new NavData objects with all_times and interpolate ECEF coordinates\n","  gt_ecef_interp = glp.NavData(gps_millis=all_times)\n","  gt_ecef_interp[\"x_rx_ecef_m\"] = glp.interpolate(gt_ecef.copy(), \"gps_millis\", \"x_rx_ecef_m\", gps_millis=all_times)[\"x_rx_ecef_m\"]\n","  gt_ecef_interp[\"y_rx_ecef_m\"] = glp.interpolate(gt_ecef.copy(), \"gps_millis\", \"y_rx_ecef_m\", gps_millis=all_times)[\"y_rx_ecef_m\"]\n","  gt_ecef_interp[\"z_rx_ecef_m\"] = glp.interpolate(gt_ecef.copy(), \"gps_millis\", \"z_rx_ecef_m\", gps_millis=all_times)[\"z_rx_ecef_m\"]\n","\n","  est_ecef_interp = glp.NavData(gps_millis=all_times)\n","  est_ecef_interp[\"x_rx_ecef_m\"] = glp.interpolate(est_ecef.copy(), \"gps_millis\", \"x_rx_ecef_m\", gps_millis=all_times)[\"x_rx_ecef_m\"]\n","  est_ecef_interp[\"y_rx_ecef_m\"] = glp.interpolate(est_ecef.copy(), \"gps_millis\", \"y_rx_ecef_m\", gps_millis=all_times)[\"y_rx_ecef_m\"]\n","  est_ecef_interp[\"z_rx_ecef_m\"] = glp.interpolate(est_ecef.copy(), \"gps_millis\", \"z_rx_ecef_m\", gps_millis=all_times)[\"z_rx_ecef_m\"]\n","\n","  # Remove NaNs from interpolated data to ensure valid points for comparison\n","  valid_indices = ~np.isnan(gt_ecef_interp[\"x_rx_ecef_m\"]) & ~np.isnan(est_ecef_interp[\"x_rx_ecef_m\"])\n","  gt_ecef_interp = gt_ecef_interp.where(valid_indices)\n","  est_ecef_interp = est_ecef_interp.where(valid_indices)\n","\n","  # Check if there's still data after interpolation and nan removal\n","  if len(gt_ecef_interp) == 0 or len(est_ecef_interp) == 0:\n","    print(\"Warning: No common valid time points for error calculation after interpolation.\")\n","    return None, None # Return None for both figures\n","\n","  # Establish LocalCoord from the first valid ground truth point\n","  # Convert the first ECEF point of ground truth back to geodetic to set the NED origin\n","  ref_geodetic = glp.coordinates.transform_coordinates(\n","      gt_ecef_interp.where(\"gps_millis\", gt_ecef_interp[\"gps_millis\"][0]),\n","      \"ecef\", \"geodetic\",\n","      x_col=\"x_rx_ecef_m\", y_col=\"y_rx_ecef_m\", z_col=\"z_rx_ecef_m\"\n","  ).get_array([\"lat_rx_geodetic_deg\", \"lon_rx_geodetic_deg\", \"alt_rx_geodetic_m\"])[:,0]\n","\n","  lc = glp.LocalCoord.from_geodetic(np.atleast_2d(ref_geodetic))\n","\n","  # Convert ECEF to NED using the established local coordinate system\n","  gt_ned = lc.ecef_to_ned(gt_ecef_interp.get_array([\"x_rx_ecef_m\", \"y_rx_ecef_m\", \"z_rx_ecef_m\"]))\n","  est_ned = lc.ecef_to_ned(est_ecef_interp.get_array([\"x_rx_ecef_m\", \"y_rx_ecef_m\", \"z_rx_ecef_m\"]))\n","\n","  errors_ned = est_ned - gt_ned # Estimate - Ground_Truth for errors\n","\n","  # Now, total error is the norm of NED errors\n","  errors = np.linalg.norm(errors_ned, axis=0)\n","\n","##\n","\n","  gt_indexes = [i[0] for i in glp.find_wildcard_indexes(ground_truth,[\"lat_rx_*_deg\",\"lon_rx_*_deg\",\"alt_rx_*_m\"],\n","                                                  max_allow=1).values()]\n","  est_indexes = [i[0] for i in glp.find_wildcard_indexes(estimate,[\"lat_rx_*_m\",\"lon_rx_*_m\",\"alt_rx_*_m\"],\n","                                                  max_allow=1).values()]\n","\n","  # Convert geodetic to ECEF for both ground truth and estimate\n","  gt_ecef = glp.geodetic_to_ecef(ground_truth[1:,0:3])\n","  est_ecef = glp.geodetic_to_ecef(estimate[:,16:19])\n","\n","  # Align time samples for accurate comparison by interpolating both to a common set of timestamps\n","  all_times = np.union1d(ground_truth[\"gps_millis\"].astype(np.int64), estimate[\"gps_millis\"].astype(np.int64))\n","\n","\n","  errors = np.linalg.norm(estimate[est_indexes] \\\n","                         -ground_truth[gt_indexes],axis=0)\n","  fig, axs = plt.subplots(2,2)\n","\n","  # plot histogram of total errors\n","  plt.subplot(221)\n","  plt.hist(errors,bins=50)\n","  plt.title(\"Total Error [m]\")\n","\n","  # NED errors\n","  lc = glp.LocalCoord.from_geodetic(np.atleast_2d(ground_truth[gt_indexes,0]))\n","  gt_ned = lc.ecef_to_ned(ground_truth[gt_indexes])\n","  est_ned = lc.ecef_to_ned(estimate[est_indexes])\n","  errors_ned = gt_ned-est_ned\n","\n","  # plot histogram of total errors\n","  plt.subplot(221)\n","  plt.hist(errors,bins=50)\n","  plt.title(\"Total Error [m]\")\n","\n","  # North errors\n","  plt.subplot(222)\n","  plt.hist(errors_ned[0,:],bins=50)\n","  plt.title(\"North Error [m]\")\n","\n","  # East errors\n","  plt.subplot(223)\n","  plt.hist(errors_ned[1,:],bins=50)\n","  plt.title(\"East Error [m]\")\n","\n","  # Down errors\n","  plt.subplot(224)\n","  plt.hist(errors_ned[2,:],bins=50)\n","  plt.title(\"Down Error [m]\")\n","\n","  plt.tight_layout()\n","\n","  # 2D Error Histogram\n","  fig2, axs2 = plt.subplots(1,1)\n","  plt.hist2d(errors_ned[1,:],errors_ned[0,:],bins=50,cmin=1)\n","  plt.xlabel(\"East Error [m]\")\n","  plt.ylabel(\"North Error [m]\")\n","  plt.colorbar()\n","  plt.title(\"2D Error Histogram\")\n","\n","  return fig, fig2"]},{"cell_type":"code","source":[],"metadata":{"id":"WkuVnIXEuYXU"},"execution_count":null,"outputs":[]},{"cell_type":"markdown","source":["## Check the Distribution of the Errors\n","- Why do you think the distribution would be like this?"],"metadata":{"id":"fsv3Omu7vI70"}},{"cell_type":"code","execution_count":68,"metadata":{"executionInfo":{"elapsed":32,"status":"error","timestamp":1764542745328,"user":{"displayName":"Gabriela Gonzalez Ayala","userId":"16947320074344909222"},"user_tz":480},"id":"x9uH6tX1GUYJ","colab":{"base_uri":"https://localhost:8080/","height":332},"outputId":"aed6d784-f41e-4d9c-ebf7-6c8bcbaac332"},"outputs":[{"output_type":"error","ename":"ValueError","evalue":"operands could not be broadcast together with shapes (3,3118) (3,442) ","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)","\u001b[0;32m/tmp/ipython-input-1235269324.py\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     10\u001b[0m \u001b[0mtruth_navdata3\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mglp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mNavData\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpandas_df\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mtruth3\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     11\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 12\u001b[0;31m \u001b[0mfigAngela\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0merror_histogram\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtruth_navdata2\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfixes_gnss_Angela\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     13\u001b[0m \u001b[0mfigGaby\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0merror_histogram\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtruth_navdata3\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfixes_gnss_Gaby\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     14\u001b[0m \u001b[0mfigTogether\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0merror_histogram\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtruth_navdata\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfixes_gnss_Together\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/tmp/ipython-input-2991893103.py\u001b[0m in \u001b[0;36merror_histogram\u001b[0;34m(ground_truth, estimate)\u001b[0m\n\u001b[1;32m      8\u001b[0m   est_indexes = [i[0] for i in glp.find_wildcard_indexes(estimate,[\"lat_rx_*_deg\",\"lon_rx_*_deg\",\"alt_rx_*_m\"],\n\u001b[1;32m      9\u001b[0m                                                   max_allow=1).values()]\n\u001b[0;32m---> 10\u001b[0;31m   errors = np.linalg.norm(estimate[est_indexes] \\\n\u001b[0m\u001b[1;32m     11\u001b[0m                          -ground_truth[gt_indexes],axis=0)\n\u001b[1;32m     12\u001b[0m   \u001b[0mfig\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0maxs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mplt\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msubplots\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;31mValueError\u001b[0m: operands could not be broadcast together with shapes (3,3118) (3,442) "]}],"source":["# histogram of error values\n","\n","truth.rename(columns={'time': 'gps_millis'}, inplace=True)\n","truth_navdata = glp.NavData(pandas_df=truth)\n","\n","truth2.rename(columns={'time': 'gps_millis'}, inplace=True)\n","truth_navdata2 = glp.NavData(pandas_df=truth2)\n","\n","truth3.rename(columns={'time': 'gps_millis'}, inplace=True)\n","truth_navdata3 = glp.NavData(pandas_df=truth3)\n","\n","figAngela = error_histogram(truth_navdata2, fixes_gnss_Angela[0])\n","figGaby = error_histogram(truth_navdata3, fixes_gnss_Gaby[0])\n","figTogether = error_histogram(truth_navdata, fixes_gnss_Together[0])"]},{"cell_type":"code","execution_count":54,"metadata":{"id":"9ZN59_7IFCr5","executionInfo":{"status":"ok","timestamp":1764541730919,"user_tz":480,"elapsed":37,"user":{"displayName":"Gabriela Gonzalez Ayala","userId":"16947320074344909222"}}},"outputs":[],"source":["def calculate_rmse(ground_truth, estimate):\n","  \"\"\"Return RMSE.\n","\n","  \"\"\"\n","\n","  gt_indexes = [i[0] for i in glp.find_wildcard_indexes(ground_truth,[\"lat_rx_*_deg\",\"lon_rx_*_deg\",\"alt_rx_*_m\"],\n","                                                  max_allow=1).values()]\n","  est_indexes = [i[0] for i in glp.find_wildcard_indexes(estimate,[\"lat_rx_*_deg\",\"lon_rx_*_deg\",\"alt_rx_*_m\"],\n","                                                  max_allow=1).values()]\n","\n","  errors = np.linalg.norm(estimate[est_indexes] \\\n","                         -ground_truth[gt_indexes],axis=0)\n","\n","  rmse = np.sqrt(np.mean(np.array(errors)**2))\n","\n","  return rmse"]},{"cell_type":"code","execution_count":56,"metadata":{"executionInfo":{"elapsed":47,"status":"error","timestamp":1764542520226,"user":{"displayName":"Gabriela Gonzalez Ayala","userId":"16947320074344909222"},"user_tz":480},"id":"lLxLRnntkBp1","colab":{"base_uri":"https://localhost:8080/","height":315},"outputId":"0c6cc634-ca15-4dd6-ce58-8e204fb67365"},"outputs":[{"output_type":"error","ename":"AttributeError","evalue":"'numpy.ndarray' object has no attribute 'to_numpy'","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mAttributeError\u001b[0m                            Traceback (most recent call last)","\u001b[0;32m/tmp/ipython-input-1724369223.py\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[0mtruth\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mrename\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcolumns\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0;34m'time'\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0;34m'gps_millis'\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0minplace\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mTrue\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[0mtruth_navdata\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mglp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mNavData\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpandas_df\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mtruth\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 3\u001b[0;31m \u001b[0mfixes_gnss_Together_interpolated\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0minterpolate_bridge\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtruth_navdata\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfixes_gnss_Together\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      4\u001b[0m \u001b[0mcalculate_rmse\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtruth_navdata\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfixes_gnss_Together_interpolated\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m/tmp/ipython-input-1738916378.py\u001b[0m in \u001b[0;36minterpolate_bridge\u001b[0;34m(ground_truth, estimate)\u001b[0m\n\u001b[1;32m     10\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     11\u001b[0m   \u001b[0;31m# Ensure gps_millis are numeric (float then int) for robust conversion and set operations\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 12\u001b[0;31m   \u001b[0mgt_gps_millis_values\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mground_truth\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"gps_millis\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mto_numpy\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     13\u001b[0m   \u001b[0minterp_gps_millis_values\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0minterpolated\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"gps_millis\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mto_numpy\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     14\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;31mAttributeError\u001b[0m: 'numpy.ndarray' object has no attribute 'to_numpy'"]}],"source":["truth.rename(columns={'time': 'gps_millis'}, inplace=True)\n","truth_navdata = glp.NavData(pandas_df=truth)\n","fixes_gnss_Together_interpolated = interpolate_bridge(truth_navdata, fixes_gnss_Together[0])\n","calculate_rmse(truth_navdata, fixes_gnss_Together_interpolated)"]},{"cell_type":"markdown","source":["**residual plots**"],"metadata":{"id":"V2M1AgTnc-47"}},{"cell_type":"code","source":["glp.solve_residuals(navdata, wls_estimate_interpolated, inplace=True)\n","for row in navdata.rows:\n","  print(row)"],"metadata":{"id":"MrgjOTsLdB7R"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["figs = glp.plot_metric_by_constellation(navdata, \"gps_millis\", \"residuals_m\")"],"metadata":{"id":"737qA91ndfNL"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"PyLwetdXGVDQ"},"outputs":[],"source":["def check_result(ground_truth, estimate, default_estimate=wls_estimate_default):\n","  \"\"\"Print RSME and plot map of estimate\n","\n","  \"\"\"\n","  default_interpolated = default_estimate.rename({\"lat_rx_wls_deg\":\"lat_rx_\" + \"default\" + \"_deg\",\n","                                                  \"lon_rx_wls_deg\":\"lon_rx_\" + \"default\" + \"_deg\",\n","                                                  \"alt_rx_wls_m\":\"alt_rx_\" + \"default\" + \"_m\",\n","                                                  })\n","  default_interpolated = interpolate_bridge(ground_truth, default_estimate)\n","  rsme_default = calculate_rmse(ground_truth, default_interpolated)\n","  print(\"The RSME for the default WLS is: \",rsme_default)\n","\n","  estimate_interpolated = interpolate_bridge(ground_truth, estimate)\n","  rsme_estimate = calculate_rmse(ground_truth, estimate_interpolated)\n","  print(\"The RSME for the new estimate is: \",rsme_estimate)\n","\n","  fig = glp.plot_map(ground_truth,\n","                     default_interpolated,\n","                     estimate_interpolated)\n","\n","  return fig"]},{"cell_type":"markdown","metadata":{"id":"rumL-wPr4GA0"},"source":["## WLS1: Custom Weighting based on C/N0"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"5VuqdaKwBJhs"},"outputs":[],"source":["# Hartinger, Horst, and Fritz K. Brunner. \"Variances of GPS phase observations:\n","# the SIGMA-ɛ model.\" GPS solutions 2 (1999): 35-43.\n","navdata[\"weights\"] = 1./(10**(-navdata[\"cn0_dbhz\"]/10.))\n","\n","wls_estimate_cn0 = glp.solve_wls(navdata.where(\"gnss_id\",(\"gps\")),weight_type=\"weights\")\n","\n","# need to not override previous data\n","wls_estimate_cn0.rename({\"lat_rx_wls_deg\":\"lat_rx_\" + \"cn0\" + \"_deg\",\n","                           \"lon_rx_wls_deg\":\"lon_rx_\" + \"cn0\" + \"_deg\",\n","                           \"alt_rx_wls_m\":\"alt_rx_\" + \"cn0\" + \"_m\",\n","                        }, inplace=True)"]},{"cell_type":"code","source":["print(wls_estimate_cn0.rows)\n","plt.plot(wls_estimate_cn0[\"alt_rx_cn0_m\"])"],"metadata":{"id":"oXDgeHNb3vwr"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"5qVMefHpBJh5"},"outputs":[],"source":["check_result(ground_truth, wls_estimate_cn0)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"8P2NkmvBHAFu"},"outputs":[],"source":["# Morton, Y. Jade, et al., eds. Position, navigation, and timing technologies in\n","# the 21st century: Integrated satellite navigation, sensor systems, and civil\n","# applications, volume 1. John Wiley & Sons, 2021. Section 11.3.1.\n","navdata[\"weights\"] = 1./navdata[\"raw_pr_sigma_m\"]**2\n","\n","wls_estimate_sigma = glp.solve_wls(navdata,weight_type=\"weights\")\n","\n","wls_estimate_sigma.rename({\"lat_rx_wls_deg\":\"lat_rx_\" + \"sigma\" + \"_deg\",\n","                           \"lon_rx_wls_deg\":\"lon_rx_\" + \"sigma\" + \"_deg\",\n","                           \"alt_rx_wls_m\":\"alt_rx_\" + \"sigma\" + \"_m\",\n","                          }, inplace=True)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"WHLPL5ny4smO"},"outputs":[],"source":["check_result(ground_truth, wls_estimate_sigma)"]},{"cell_type":"markdown","metadata":{"id":"d-QMGPeQCVXb"},"source":["# WLS2: Elevation Masks"]},{"cell_type":"markdown","metadata":{"id":"b06lLhwFCYsZ"},"source":["We can add an elevation mask to get rid of low elevation satellites."]},{"cell_type":"code","execution_count":null,"metadata":{"id":"evY9Y4p4HB70"},"outputs":[],"source":["# add elevation and azimuth to data\n","navdata = glp.add_el_az(navdata,wls_estimate_sigma,inplace=True)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"kLGQ4QnISz2J"},"outputs":[],"source":["fig = glp.plot_skyplot(navdata,wls_estimate_sigma)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Tn-cNw4sY-RK"},"outputs":[],"source":["cropped_navdata = navdata.where(\"el_sv_deg\",30.,\"geq\")\n","fig = glp.plot_skyplot(cropped_navdata,wls_estimate_sigma)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"hNQ5EjfIHn9M"},"outputs":[],"source":["wls_estimate_el_mask = glp.solve_wls(cropped_navdata)\n","\n","wls_estimate_el_mask.rename({\"lat_rx_wls_deg\":\"lat_rx_\" + \"el_mask\" + \"_deg\",\n","                           \"lon_rx_wls_deg\":\"lon_rx_\" + \"el_mask\" + \"_deg\",\n","                           \"alt_rx_wls_m\":\"alt_rx_\" + \"el_mask\" + \"_m\",\n","                          }, inplace=True)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"2iYokNcYHrM8"},"outputs":[],"source":["check_result(ground_truth, wls_estimate_el_mask)"]},{"cell_type":"markdown","metadata":{"id":"nyFfCf93LFMD"},"source":["# WLS 3: Carrier-to-Noise Power Density based on Constellation"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"9ih3bzB7HiXT"},"outputs":[],"source":["# add signal type to glonass signal partially lost under the bridge\n","navdata[\"signal_type\",navdata.argwhere(\"corr_pr_m\",np.nan)] = np.array([\"g1\"])\n","\n","figs = glp.plot_metric_by_constellation(navdata,\"gps_millis\",\"cn0_dbhz\",\n","                                        alpha=0.5, marker=\"None\")"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"Y2pTtmZ7Kf6-"},"outputs":[],"source":["fig = glp.plot_metric(navdata,\"gps_millis\",\"cn0_dbhz\",\n","                      groupby=\"gnss_id\",\n","                      alpha=0.5, marker=\"None\")"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"b5d8s6PNHIr9"},"outputs":[],"source":["navdata_gps_glonass = navdata.where(\"gnss_id\",(\"gps\",\"glonass\"))\n","wls_estimate_gps_glonass = glp.solve_wls(navdata_gps_glonass)\n","\n","wls_estimate_gps_glonass.rename({\"lat_rx_wls_deg\":\"lat_rx_\" + \"gps_glonass\" + \"_deg\",\n","                                 \"lon_rx_wls_deg\":\"lon_rx_\" + \"gps_glonass\" + \"_deg\",\n","                                 \"alt_rx_wls_m\":\"alt_rx_\" + \"gps_glonass\" + \"_m\",\n","                                 }, inplace=True)"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"vI_HDTvYMDtg"},"outputs":[],"source":["check_result(ground_truth,wls_estimate_gps_glonass)"]},{"cell_type":"markdown","metadata":{"id":"ZV7pat1EMwey"},"source":["## Many more tutorials on `gnss_lib_py` website!\n","[https://gnss-lib-py.readthedocs.io/en/latest/tutorials/tutorials.html](https://gnss-lib-py.readthedocs.io/en/latest/tutorials/tutorials.html)"]},{"cell_type":"markdown","metadata":{"id":"5lIdluJ2NE2Z"},"source":["## Student Challenge\n","How low can you make your WLS RMS error value?\n","\n","Ideas:\n","*   Different weighting parameters for WLS\n","*   Mask values based on constellation, elevation, other? Check what rows exist with ``print(navdata.rows)``\n","*   Combinations of masks and weighting parameters\n","*   Any way of using residuals?\n","\n","\n","\n"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"9EseQv1NND9M"},"outputs":[],"source":["from types import new_class\n","def my_solution(navdata, solution_name):\n","  \"\"\"Custom student estimate.\n","\n","  You cannot add additional inputs into this function!\n","\n","  Parameters\n","  ----------\n","  navdata : glp.android.AndroidDerived2022\n","    Input measurement data.\n","  solution_name : string\n","    Custom name for your solution.\n","\n","  Returns\n","  -------\n","  estimate :\n","\n","  \"\"\"\n","\n","  # copy navdata to avoid overwriting\n","  navdata_cropped = navdata.copy()\n","\n","  ########################################################\n","  ######## ADD YOUR CUSTOM SOLUTION BELOW HERE! ##########\n","  ########################################################\n","\n","  # default: comment out the line below\n","  new_navdata = navdata_cropped.where(\"el_sv_deg\",20.,\"geq\")\n","  # new_navdata = navdata_cropped\n","  new_navdata = new_navdata.where(\"gnss_id\",(\"gps\",\"galileo\",\"beidou\"))\n","\n","  new_navdata[\"weights\"] = 1./new_navdata[\"raw_pr_sigma_m\"]**2\n","\n","  estimate = glp.solve_wls(new_navdata,weight_type=\"weights\")\n","  # estimate = glp.solve_wls(new_navdata)\n","\n","  ########################################################\n","  ######## ADD YOUR CUSTOM SOLUTION ABOVE HERE! ##########\n","  ########################################################\n","\n","  estimate.rename({\"lat_rx_wls_deg\":\"lat_rx_\" + solution_name + \"_deg\",\n","                   \"lon_rx_wls_deg\":\"lon_rx_\" + solution_name + \"_deg\",\n","                   \"alt_rx_wls_m\":\"alt_rx_\" + solution_name + \"_m\",\n","                   }, inplace=True)\n","\n","  return estimate"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"97n1fh4SaVFL"},"outputs":[],"source":["estimate = my_solution(navdata, solution_name=\"your_team\")"]},{"cell_type":"code","execution_count":null,"metadata":{"id":"jVluz9FIP0Ew"},"outputs":[],"source":["check_result(ground_truth,estimate)"]},{"cell_type":"code","source":[],"metadata":{"id":"IuzVGCrni4hc"},"execution_count":null,"outputs":[]}],"metadata":{"colab":{"provenance":[{"file_id":"1yUiayRT9xgwf97yf_wEtVk2vd4pTex94","timestamp":1760992118657},{"file_id":"1DkhUPuG2SYYR0bNWtO5j6WfGeKaWkDc5","timestamp":1728957063002}]},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}